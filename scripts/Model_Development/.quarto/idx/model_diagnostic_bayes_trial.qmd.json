{"title":"Model diagnostics","markdown":{"yaml":{"title":"Model diagnostics","output":{"html_document":{"toc":true,"toc_float":true,"depth":2}},"params":{"run":"5","logDV":false,"include_code":false,"include_plots":true,"sims_output_path":"","n_post":1000,"resid_var":true,"ipred_sim":true,"ci_level":95,"plot_ci":false,"run_mrggsave":true}},"headingText":"Run number `r params$run`","containsRefs":false,"markdown":"\n\n\nTo produce a set of diagnostic plots that will be included in a report. Please\nnote that these plots are just meant to provide an example of what could be\ncreated and how. They are not an exhaustive list of every possible plot and were\nchosen with the project aims in mind.\n\n# Set up\n\n```{r setup_general, include = F}\n### General script set-up\nknitr::opts_chunk$set(\n  echo = TRUE,\n  warning = FALSE,\n  message = FALSE,\n  fig.height = 5,\n  fig.width = 5\n)\n\n### Libraries ----------------------------\nsuppressPackageStartupMessages(library(tidyverse))\nlibrary(pmplots)\nlibrary(bbr)\nlibrary(bbr.bayes)\nsuppressPackageStartupMessages(library(posterior))\nlibrary(bayesplot)\nlibrary(yspec)\nlibrary(mrggsave)\nlibrary(pmtables)\nlibrary(mrgsolve)\nlibrary(furrr)\nlibrary(patchwork)\nlibrary(glue)\nlibrary(cowplot)\nlibrary(here)\n\n### Directories ----------------------------\nfigDir <- here::here(\"deliv\", \"figures\", \"MCMC\")\ndataDir <- here::here(\"data\")\n\nif (!file.exists(figDir)) dir.create(figDir)\n\nthisScript <- params$script\noptions(\n  mrg.script = params$script,\n  mrggsave.dev = \"pdf,png\"\n)\n\ntheme_set(pmplots::pm_theme())\n\nif (params$plot_ci && params$sims_output_path == \"\") {\n  stop(\"Set `sims_output_path` (after running simulations) in order to plot CIs\")\n}\n```\n\n\n```{r load_any_functions, include = F}\n### Source function scripts\nsource(here::here(\"scripts/Model_Bayes_Approach/functions-mcmc-diagnostics.R\"))\nsource(here::here(\"scripts/Model_Bayes_Approach/functions-diagnostics-rhat-ess.R\"))\n```\n\n### Model location\n\nDefine `modelName` and path to the model directory (`MODEL_DIR`).\n\n```{r setup_bbr, echo = params$include_code, message = FALSE}\n# Set directories for bbr models ----------------------------\nMODEL_DIR <- params$modelDir\nmodelName <- params$run\nthisModelPath <- file.path(MODEL_DIR, modelName)\n```\n\n### Figure location\n\nIf saving figures out to pdf, define where those pdfs should be saved to.\nHere the figures are saved to ```deliv > figure > model_run_number```\n\n```{r makeDir_mrggsave, echo = params$include_code, eval = params$run_mrggsave}\nthisFigDir <- file.path(figDir, modelName)\nif (!file.exists(thisFigDir)) dir.create(thisFigDir)\n\n### set mrggsave figure directory here\noptions(mrggsave.dir = thisFigDir)\n```\n\n\n\n# Model details\n\nA summary of high-level model details.\n\nRead in the model details using `read_model`. Details stored in the `mod` object\ncan be used to identify the location of the source data (used in $DATA) - to see\nhow this is done look at the `bbr::get_data_path()` and\n`bbr::build_path_from_model()` helper functions.\n\n```{r modelDetails, echo = params$include_code, results = \"asis\"}\nmod <- read_model(file.path(MODEL_DIR, params$run))\nmod\n```\n\n### Read output\n\n```{r modelOutputSummary, echo = params$include_code}\n# `draws_array` object from the `posterior` package\ndraws <- read_fit_model(mod)\nn_chains <- nchains(draws)\nn_iter <- niterations(draws)\n\n# Summary of the posterior \ndraws_param <- subset_draws(draws, variable = c(\"THETA\", \"OMEGA\", \"SIGMA\"))\ndraws_sum <- draws_param %>% \n  summarize_draws()\n\n# Calculate shrinkage from post hoc ETAs, or from the .shk files if the .iph\n# files do not exist\nshk0 <- shrinkage(mod)\nomegas <- variables(draws) %>% \n  str_subset(\"^OMEGA\") %>% \n  # diagonals only\n  str_subset(\"\\\\[(\\\\d+),\\\\1\\\\]\")\nshk <- tibble(variable = omegas, shrinkage = shk0)\n```\n\n## Parameter estimates \n\nCompute summaries of posterior distributions as well as some diagnostics.\n\nBulk effective sample size (ESS) is a measure of sampling efficiency for the\nlocation of the distribution, while Tail ESS is a measure of sampling efficiency\nfor the tails (5% and 95% quantiles) of the distribution. Higher values indicate\ngreater sampling efficiency.  A very rough rule of thumb is to aim for at least\n400 for each parameter.\n\nR-hat is a convergence diagnostic that compares the between- and within-chain\nvariances of model parameters. Values close to 1 indicate that the chains have\nconverged to similar distributions.  Aim for less than about 1.05 for all\nparameters.\n\nThis is a repeat of the summary table produces in the MCMC diagnostics template,\nbut can be usedful to include here to refer to when considering model\ndiagnostics.\n\n```{r summary, echo = FALSE}\nptable <- draws_sum %>% \n  mutate_if(is.numeric, ~formatC(., 3)) %>% \n  rename(parameter = variable) %>%\n  mutate(\"90% CI\" = paste(\"(\", q5, \", \", q95, \")\", \n                          sep = \"\")) %>%\n  select(parameter, mean, median, sd, mad, \"90% CI\", ess_bulk, ess_tail, rhat)\n\nptable %>% \n  knitr::kable(caption = \"Summary of model parameter estimates.\")\n```\n\n\n# Read in data\n\nModel output (EPRED, IPRED, NPDE, EWRES, ETAs) is read in from either the output\nof simulations (see `?bbr.bayes::nm_join_bayes`) or from NONMEM output only.\nWhen only NONMEM output is used, medians of these values across all chains are\ncalculated.\n\nAfter reading in the NONMEM dataset and the output dataset they're joined by a\n`NUM` column. **This assumes that a row number column (called `NUM`) was\nincluded during data assembly.** The idea here is that in NONMEM, you table\njust `NUM` and none of the other input data items. They all will get joined\nback to the NONMEM output ... even character columns.\n\nThe `data` used in the diagnostic plots has been filtered to only include the\nobservations (i.e. `EVID==0`). Note that further modifications may be needed, for\nexample, if BLQ data was included in the model or if the `DV` was\nlog-transformed. The dataset also converts the categorical covariates of\ninterest to factors using the `yspec_add_factors` function and details described\nin the spec file.\n\nThe `id` subset gets the first record per ID. This would usually be the baseline\nvalue but consider filtering on a baseline flag if available. Also, if the model\nincludes inter-occasion variability (IOV), the occasion variable should be\nincluded within the `distinct` function.\n\n```{r read_in_data, echo = params$include_code, message=FALSE}\n# load in the spec file\nspec <- ys_load(params$yspec)\n\nif (params$sims_output_path != \"\") {\n  if (!file.exists(params$sims_output_path)) {\n    stop(glue(\"File {params$sims_output_path} does not exist\"))\n  } else {\n    data0 <- readRDS(params$sims_output_path)\n  }\n} else {\n  data0 <- nm_join_bayes_quick(mod)\n}\n\n# filter to observation rows only\ndata <- data0 %>%\n  filter(EVID == 0) %>%\n  yspec_add_factors(spec, .suffix = \"\")\n\nif (isTRUE(params$logDV)) {\n  data <- mutate(data,\n    LNPRED = PRED,\n    PRED = exp(PRED),\n  )\n}\n\n# filter to single row per ID and include factors\nid <- distinct(data, ID, .keep_all = TRUE)\n```\n\n```{r desc_test, include = F}\n# Descriptive text that depends on the settings used for diagnostic simulations\n# (and whether diagnostic simulations were run at all)\n\nind_pred_text <- glue(\n  \"Individual predictions are medians of the values of IPRED output by NONMEM\n  for each of the {n_chains} chains.\"\n)\netas_text <- glue(\n  \"ETAs are medians of the values\n  of ETA output by NONMEM for each of the {n_chains} chains.\"\n)\nif (params$sims_output_path == \"\") {\n  # Medians of NONMEM output only\n  pop_pred_text <- glue(\n    \"Population predictions are medians of the values of EPRED output by NONMEM\n    for each of the {n_chains} chains.\"\n  )\n  dv_pred_text <- glue(pop_pred_text, ind_pred_text, .sep = \" \")\n  npde_text <- glue(\n    \"Normalized prediction distribution errors (NPDE) are medians of the values\n    of NPDE output by NONMEM for each of the {n_chains} chains.\"\n  )\n  ewres_text <- glue(\n    \"Expected weighted residuals (EWRES) are medians of the values\n    of EWRES output by NONMEM for each of the {n_chains} chains.\"\n  )\n} else {\n  # Medians (and optionally upper/lower percentiles) from simulations\n  pop_pred_text <- glue(\n    \"Population predictions are medians of {params$n_post} simulated values\n    incorporating between-{ifelse(params$resid_var, ' and within-', '')}subject\n    variability, as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n  if (params$ipred_sim) {\n    ind_pred_text <- glue(\n      \"Individual predictions are medians of {params$n_post} simulated values\n      incorporating conditional estimates of individual parameters and include\n      {ifelse(params$resid_var, 'within-subject variability, as well as', '')}\n      uncertainty in population parameter estimates via sampling from the\n      posterior distribution.\"\n    )\n    etas_text <- glue(\n      \"ETAs are medians of {params$n_post} posterior ETAs across\n      the {n_chains} chains.\"\n    )\n  }\n  dv_pred_text <- glue(pop_pred_text, ind_pred_text, .sep = \" \")\n  if (params$plot_ci) {\n    dv_pred_text <- glue(\n      dv_pred_text,\n      \" Red error bars represent {params$ci_level}% CIs.\"\n    )\n  }\n  npde_text <- glue(\n    \"Normalized prediction distribution errors (NPDE) are Monte-Carlo generated\n    diagnostics, using {params$n_post} simulations incorporating\n    between-{ifelse(params$resid_var, ' and within-', '')}subject variability,\n    as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n  ewres_text <- glue(\n    \"Expected weighted residuals (EWRES) are Monte-Carlo generated residuals,\n    using {params$n_post} simulations incorporating\n    between-{ifelse(params$resid_var, ' and within-', '')}subject variability,\n    as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n}\n```\n\n\n\n# General diagnostic plots\n\nThe following plots assume that the preferred x-axis labels are defined here. \n\n```{r xAxis_label_names, echo = params$include_code}\n### Ideally get units from yaml\n\nxTIME <- \"TIME //Time (h)\"\nxTAD <- \"TAD //Time after dose (h)\"\nxPRED <- \"EPRED //Population predicted concentration\"\nyEWRES <- \"EWRES //Expected weighted residual\"\nyNPDE <- \"NPDE //Normalized prediction distribution error\"\n```\n\n## DV vs population and individual predictions\n\nCreate plots of DV vs population and individual predictions for the full dataset\nand stratified by renal function and hepatic function.\n\n```{r DV_PRED_plots, echo = params$include_code, message=FALSE}\n# DV vs population predictions\ndv_pred_ci <- function(data, scales_free = FALSE) {\n  p <- ggplot(data = data, aes(x = EPRED, y = DV)) + \n    geom_errorbarh(aes(xmin = EPRED_lo, xmax = EPRED_hi), \n                   colour = \"red3\", alpha = 0.3) + \n    geom_point() + \n    xlab(glue(\"Population predicted value\")) + ylab(\"Observed value\") +  \n    pm_abline() + pm_smooth() + pm_theme()\n  if (!scales_free) {\n    p <- p +\n      lims(\n        x = c(0, max(data$EPRED_hi)),\n        y = c(0, max(data$EPRED_hi))\n      )\n  }\n  p\n}\nif (params$plot_ci & params$sims_output_path != \"\") {\n  dvp <- dv_pred_ci(data)\n  # by renal function\n  dvp_rf <- dv_pred_ci(data, scales_free = TRUE) +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvp_cp <- dv_pred_ci(data, scales_free = TRUE) +\n    facet_wrap(~CP, scales = \"free\")\n} else {\n  dvp <- dv_pred(data, x = \"EPRED//Population predicted {xname}\")\n  # by renal function\n  dvp_rf <- dv_pred(data, x = \"EPRED//Population predicted {xname}\", scales = \"free\") +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvp_cp <- dv_pred(data, x = \"EPRED//Population predicted {xname}\", scales = \"free\") +\n    facet_wrap(~CP, scales = \"free\")\n}\n\n# DV vs individual predictions\ndv_ipred_ci <- function(data, scales_free = FALSE) {\n  p <- ggplot(data = data, aes(x = IPRED, y = DV)) + \n    geom_errorbarh(aes(xmin = IPRED_lo, xmax = IPRED_hi), \n                   colour = \"red3\", alpha = 0.3) + \n    geom_point() + \n    xlab(\"Individual predicted value\") + ylab(\"Observed value\") +  \n    pm_abline() + pm_smooth() + pm_theme()\n  if (!scales_free) {\n    p <- p +\n      lims(\n        x = c(0, max(data$IPRED_hi)),\n        y = c(0, max(data$IPRED_hi))\n      )\n  }\n  p\n}\nif (params$plot_ci & params$sims_output_path != \"\" &\n    \"IPRED_lo\" %in% names(data)) {\n  dvip <- dv_ipred_ci(data)\n  # by renal function\n  dvip_rf <- dv_ipred_ci(data, scales_free = TRUE) +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvip_cp <- dv_ipred_ci(data, scales_free = TRUE) +\n    facet_wrap(~CP, scales = \"free\")\n} else {\n  dvip <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\")\n  # by renal function\n  dvip_rf <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\", scales = \"free\") +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvip_cp <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\", scales = \"free\") +\n    facet_wrap(~CP, scales = \"free\")\n}\n\np <- pm_grid(list(dvp, dvip), nrow = 2, ncol = 1)\n```\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\ndv_pred_text\n```\n\n```{r include_DV_PRED, include=params$include_plots, echo=F, message=FALSE}\np\n```\n\nDV vs population and individual predictions by renal function\n\n```{r include_DV_PRED_rf, include=params$include_plots, echo=F, message=FALSE}\ndvp_rf ; dvip_rf\n```\n\nDV vs population and individual predictions by hepatic function\n\n```{r include_DV_PRED_cp, include=params$include_plots, echo=F, message=FALSE}\ndvp_cp ; dvip_cp\n```\n\n\n```{r save_DV_PRED, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"dv-pred-ipred\"),\n  width = 5,\n  height = 7\n)\n\n\nmrggsave(\n  list(dvp_rf, dvip_rf), \n  stem = c(params$run, \"dv-pred-ipred-byRF\"),\n  width = 5,\n  height = 5\n)\nmrggsave(\n  list(dvp_cp, dvip_cp), \n  stem = c(params$run, \"dv-pred-ipred-byCP\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm_dv_pred, include=F}\nrm(p, dvp, dvip, dvp_rf, dvip_rf, dvp_cp, dvip_cp)\n```\n\n\n## NPDE plots\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\nnpde_text\n```\n\nNPDE vs population predictions, time and time after dose.\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\npop_pred_text\n```\n\n```{r NPDE_plots, echo = params$include_code, message = FALSE}\n## Plan to display these three plots in a single, 3 panel figure and so the y-axis\n## labels are removed manually for display purposes\np1 <- npde_pred(data, x = xPRED, y = \"NPDE //  \")\np2 <- npde_time(data, x = xTIME)\np3 <- npde_tad(data, x = xTAD, y = \"NPDE //  \")\n\np <- pm_grid(list(p1, p2, p3), nrow = 3, ncol = 1)\n```\n\n```{r include_NPDE, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE, fig.height = 7}\np\n```\n\n```{r save_NPDE, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-pred-time-tad\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2, include = F}\nrm(p)\n```\n\n\nNPDE vs continuous covariates\n\n```{r NPDE_cont_cov_plots, echo = params$include_code, message = FALSE}\nNPDEco <- spec %>%\n  ys_select(params$contCov) %>% # select the covariates of interest\n  axis_col_labs(\n    title_case = TRUE, # converts yspec short to title_case\n    short_max = 20\n  ) # if yspec short is >10 characters it keeps the abbreviation\n\np1 <- npde_cont(data, x = NPDEco[1])\np2 <- npde_cont(data, x = NPDEco[2])\np3 <- npde_cont(data, x = NPDEco[3])\np4 <- npde_cont(data, x = NPDEco[4])\n\np <- pm_grid(list(p1, p2, p3, p4), ncol = 1)\n```\n\n```{r include_NPDE_cont_cov, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE, fig.height = 7}\np\n```\n\n```{r save_NPDE_cont_cov, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-cont-cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2_cont_cov, include = F}\nrm(p)\n```\n\nNPDE vs categorical covariates.\n\n```{r NPDE_cat_cov_plots, echo = params$include_code, message = FALSE}\nNPDEca <- spec %>%\n  ys_select(\"RF\", \"CP\") %>%   # select the covariates of interest\n  axis_col_labs(title_case = TRUE) # converts yspec short to title_case\n\np1 <- npde_cat(data, x = NPDEca[1])\np2 <- npde_cat(data, x = NPDEca[2]) + rot_x(45)\n\np <- pm_grid(list(p1, p2), nrow = 2, ncol = 1)\n```\n\n```{r include_NPDE_cat_cov, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_NPDE_cat_cov, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-cat-cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2_cat_cov, include = F}\nrm(p)\n```\n\n\n## NPDE density histogram\n\n```{r npde_hist_plots, echo = params$include_code, message = FALSE}\np <- npde_hist(data)\n```\n\n```{r include_npde_hist, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_npde_hist, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-hist\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm3, include = F}\nrm(p)\n```\n\n## EWRES vs population predictions, time and time after dose\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\newres_text\n```\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\npop_pred_text\n```\n\n```{r ewres_plots, echo = params$include_code, message=FALSE}\np_ewres_epred <- res_pred(data, x = xPRED, y = yEWRES)\np_ewres_time <- res_pred(data, x = xTIME, y = yEWRES)\np_ewres_tad <- res_pred(data, x = xTAD, y = yEWRES)\np <- pm_grid(\n  list(\n    p_ewres_epred,\n    p_ewres_time,\n    p_ewres_tad\n  ),\n  nrow = 3,\n  ncol = 1\n)\n```\n\n```{r include_ewres, eval=params$include_plots, include=params$include_plots, echo=F, message=FALSE, fig.height = 7}\np\n```\n\n```{r save_ewres, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"ewres-epred-time-tad\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm_ewres_plots, include=F}\nrm(p)\n```\n\n\n\n## EWRES qq and density plot\n\n```{r ewres_qq_density_plots, echo = params$include_code, message=FALSE}\np_ewres_q <- wres_q(data, \"EWRES\")\np_ewres_hist <- cont_hist(data, \"EWRES\", y = \"..density..\")\np <- pm_grid(list(p_ewres_q, p_ewres_hist), nrow = 2, ncol = 1)\n```\n\n```{r include_ewres_qq_density, eval=params$include_plots, include=params$include_plots, echo=F, message=FALSE}\np\n```\n\n```{r save_ewres_qq_density, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"ewres-qq-hist\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm_ewres_qq_density, include=F}\nrm(p)\n```\n\n\n\n# EBEs-based diagnostics\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\netas_text\n```\n\n\n\n## ETA pairs plot \n\n```{r eta_pairs_plots, echo = params$include_code, message = FALSE}\np <- eta_pairs(id, params$etas)\n```\n\n```{r include_eta_pairs, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_pairs, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta\", \"pairs\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm5, include = F}\nrm(p)\n```\n\n\n\n\n\n## Continuous covariate plots\n\nThese plots uses yspec to automatically rename the axis labels.\n\n```{r get_cont_cov_labels, echo = params$include_code}\nco <- spec %>%\n  ys_select(params$contCov) %>% # select the covariates of interest\n  axis_col_labs(\n    title_case = TRUE, # converts yspec short to title_case\n    short_max = 20\n  ) # if yspec short is >10 characters it keeps the abbreviation\n```\n\n### ETA vs continuous covariates\n\nNote that here we use a function that maps over the ETAs (not the covariates)\nbecause the purpose of these plots was to determine whether there were any\ntrends in the covariates for a given ETA. This may need to be edited to address\ndifferent study specific questions\n\n```{r eta_vs_cont_plots, echo = params$include_code, message = FALSE}\np <- purrr::map(.x = params$etas, ~ map_wrap_eta_cont(.x, co, id, .ncol = 1))\n```\n\n```{r include_eta_vs_cont, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_vs_cont, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta-all\", \"cont\", \"cov\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm6, include = F}\nrm(p)\n```\n\n### Continuous covariate pairs plot\n\n```{r contCov_pairs_plots, echo = params$include_code, message = FALSE}\nco2 <- str_replace(co, \"\\\\(\", \"\\n(\")\np <- eta_pairs(id, co2) + rot_x(45)\n```\n\n```{r include_contCov_pairs, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_contCov_pairs, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta\", \"all\", \"contCov\", \"pairs\"),\n  width = 5,\n  height = 6\n)\n```\n\n```{r rm7, include = F}\nrm(p)\n```\n\n\n## Categorical covariate plots\n\nThese plots uses the yspec to automatically rename the axis labels.\n\n```{r get_cat_cov_labels, echo = params$include_code}\nca <- spec %>%\n  ys_select(params$catCov) %>% # select the covariates of interest\n  axis_col_labs(title_case = TRUE) # converts yspec short to title_case\n```\n\n\n### ETA vs categorical covariates\n\nNote that here we use a function that maps over the covariates (not the ETAs)\nbecause the purpose of these plots was to determine whether there is any\ndifference in the distribution of ETAs across studies, dosing groups and disease\nstates. This should be updated to reflect the questions you're trying to\naddress.\n\n\n```{r eta_vs_cat_plots, echo = params$include_code, message = FALSE}\nif (length(params$etas) > 1) {\n  p <- purrr::map(.x = ca, ~ map_eta_cat(.x, params$etas, id))\n} else {\n  ## CHECK: depending on the labels, this may need to be changed\n  p <- purrr::map(.x = ca, ~ eta_cat(id, .x, params$etas) + rot_x(35))\n}\n\npList <- pm_grid(list(p[[1]], p[[2]]), nrow = 2, ncol = 1)\n```\n\n```{r include_eta_vs_cat, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_vs_cat, include = FALSE, eval = params$run_mrggsave, message = FALSE}\n## As of mrggsave v0.4.0, if you pass mrggsave a named list of plots, it will use this to\n## name the plots that it writes out (regardless of whether stem is defined).\n## If you don't want to use this feature, you can pass unname(p), instead of just p\nmrggsave(\n  list(pList, unname(p)),\n  stem = c(params$run, \"eta\", \"all\", \"cat\", \"cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n\n# Session details\n\nIt is considered good practice to include these details at the end of all rmd scripts\n\n```{r details, include = TRUE}\nSys.getenv(\"AMI_NAME\")\nsessioninfo::session_info()\nbbr::bbi_version()\n```","srcMarkdownNoYaml":"\n\n# Run number `r params$run`\n\nTo produce a set of diagnostic plots that will be included in a report. Please\nnote that these plots are just meant to provide an example of what could be\ncreated and how. They are not an exhaustive list of every possible plot and were\nchosen with the project aims in mind.\n\n# Set up\n\n```{r setup_general, include = F}\n### General script set-up\nknitr::opts_chunk$set(\n  echo = TRUE,\n  warning = FALSE,\n  message = FALSE,\n  fig.height = 5,\n  fig.width = 5\n)\n\n### Libraries ----------------------------\nsuppressPackageStartupMessages(library(tidyverse))\nlibrary(pmplots)\nlibrary(bbr)\nlibrary(bbr.bayes)\nsuppressPackageStartupMessages(library(posterior))\nlibrary(bayesplot)\nlibrary(yspec)\nlibrary(mrggsave)\nlibrary(pmtables)\nlibrary(mrgsolve)\nlibrary(furrr)\nlibrary(patchwork)\nlibrary(glue)\nlibrary(cowplot)\nlibrary(here)\n\n### Directories ----------------------------\nfigDir <- here::here(\"deliv\", \"figures\", \"MCMC\")\ndataDir <- here::here(\"data\")\n\nif (!file.exists(figDir)) dir.create(figDir)\n\nthisScript <- params$script\noptions(\n  mrg.script = params$script,\n  mrggsave.dev = \"pdf,png\"\n)\n\ntheme_set(pmplots::pm_theme())\n\nif (params$plot_ci && params$sims_output_path == \"\") {\n  stop(\"Set `sims_output_path` (after running simulations) in order to plot CIs\")\n}\n```\n\n\n```{r load_any_functions, include = F}\n### Source function scripts\nsource(here::here(\"scripts/Model_Bayes_Approach/functions-mcmc-diagnostics.R\"))\nsource(here::here(\"scripts/Model_Bayes_Approach/functions-diagnostics-rhat-ess.R\"))\n```\n\n### Model location\n\nDefine `modelName` and path to the model directory (`MODEL_DIR`).\n\n```{r setup_bbr, echo = params$include_code, message = FALSE}\n# Set directories for bbr models ----------------------------\nMODEL_DIR <- params$modelDir\nmodelName <- params$run\nthisModelPath <- file.path(MODEL_DIR, modelName)\n```\n\n### Figure location\n\nIf saving figures out to pdf, define where those pdfs should be saved to.\nHere the figures are saved to ```deliv > figure > model_run_number```\n\n```{r makeDir_mrggsave, echo = params$include_code, eval = params$run_mrggsave}\nthisFigDir <- file.path(figDir, modelName)\nif (!file.exists(thisFigDir)) dir.create(thisFigDir)\n\n### set mrggsave figure directory here\noptions(mrggsave.dir = thisFigDir)\n```\n\n\n\n# Model details\n\nA summary of high-level model details.\n\nRead in the model details using `read_model`. Details stored in the `mod` object\ncan be used to identify the location of the source data (used in $DATA) - to see\nhow this is done look at the `bbr::get_data_path()` and\n`bbr::build_path_from_model()` helper functions.\n\n```{r modelDetails, echo = params$include_code, results = \"asis\"}\nmod <- read_model(file.path(MODEL_DIR, params$run))\nmod\n```\n\n### Read output\n\n```{r modelOutputSummary, echo = params$include_code}\n# `draws_array` object from the `posterior` package\ndraws <- read_fit_model(mod)\nn_chains <- nchains(draws)\nn_iter <- niterations(draws)\n\n# Summary of the posterior \ndraws_param <- subset_draws(draws, variable = c(\"THETA\", \"OMEGA\", \"SIGMA\"))\ndraws_sum <- draws_param %>% \n  summarize_draws()\n\n# Calculate shrinkage from post hoc ETAs, or from the .shk files if the .iph\n# files do not exist\nshk0 <- shrinkage(mod)\nomegas <- variables(draws) %>% \n  str_subset(\"^OMEGA\") %>% \n  # diagonals only\n  str_subset(\"\\\\[(\\\\d+),\\\\1\\\\]\")\nshk <- tibble(variable = omegas, shrinkage = shk0)\n```\n\n## Parameter estimates \n\nCompute summaries of posterior distributions as well as some diagnostics.\n\nBulk effective sample size (ESS) is a measure of sampling efficiency for the\nlocation of the distribution, while Tail ESS is a measure of sampling efficiency\nfor the tails (5% and 95% quantiles) of the distribution. Higher values indicate\ngreater sampling efficiency.  A very rough rule of thumb is to aim for at least\n400 for each parameter.\n\nR-hat is a convergence diagnostic that compares the between- and within-chain\nvariances of model parameters. Values close to 1 indicate that the chains have\nconverged to similar distributions.  Aim for less than about 1.05 for all\nparameters.\n\nThis is a repeat of the summary table produces in the MCMC diagnostics template,\nbut can be usedful to include here to refer to when considering model\ndiagnostics.\n\n```{r summary, echo = FALSE}\nptable <- draws_sum %>% \n  mutate_if(is.numeric, ~formatC(., 3)) %>% \n  rename(parameter = variable) %>%\n  mutate(\"90% CI\" = paste(\"(\", q5, \", \", q95, \")\", \n                          sep = \"\")) %>%\n  select(parameter, mean, median, sd, mad, \"90% CI\", ess_bulk, ess_tail, rhat)\n\nptable %>% \n  knitr::kable(caption = \"Summary of model parameter estimates.\")\n```\n\n\n# Read in data\n\nModel output (EPRED, IPRED, NPDE, EWRES, ETAs) is read in from either the output\nof simulations (see `?bbr.bayes::nm_join_bayes`) or from NONMEM output only.\nWhen only NONMEM output is used, medians of these values across all chains are\ncalculated.\n\nAfter reading in the NONMEM dataset and the output dataset they're joined by a\n`NUM` column. **This assumes that a row number column (called `NUM`) was\nincluded during data assembly.** The idea here is that in NONMEM, you table\njust `NUM` and none of the other input data items. They all will get joined\nback to the NONMEM output ... even character columns.\n\nThe `data` used in the diagnostic plots has been filtered to only include the\nobservations (i.e. `EVID==0`). Note that further modifications may be needed, for\nexample, if BLQ data was included in the model or if the `DV` was\nlog-transformed. The dataset also converts the categorical covariates of\ninterest to factors using the `yspec_add_factors` function and details described\nin the spec file.\n\nThe `id` subset gets the first record per ID. This would usually be the baseline\nvalue but consider filtering on a baseline flag if available. Also, if the model\nincludes inter-occasion variability (IOV), the occasion variable should be\nincluded within the `distinct` function.\n\n```{r read_in_data, echo = params$include_code, message=FALSE}\n# load in the spec file\nspec <- ys_load(params$yspec)\n\nif (params$sims_output_path != \"\") {\n  if (!file.exists(params$sims_output_path)) {\n    stop(glue(\"File {params$sims_output_path} does not exist\"))\n  } else {\n    data0 <- readRDS(params$sims_output_path)\n  }\n} else {\n  data0 <- nm_join_bayes_quick(mod)\n}\n\n# filter to observation rows only\ndata <- data0 %>%\n  filter(EVID == 0) %>%\n  yspec_add_factors(spec, .suffix = \"\")\n\nif (isTRUE(params$logDV)) {\n  data <- mutate(data,\n    LNPRED = PRED,\n    PRED = exp(PRED),\n  )\n}\n\n# filter to single row per ID and include factors\nid <- distinct(data, ID, .keep_all = TRUE)\n```\n\n```{r desc_test, include = F}\n# Descriptive text that depends on the settings used for diagnostic simulations\n# (and whether diagnostic simulations were run at all)\n\nind_pred_text <- glue(\n  \"Individual predictions are medians of the values of IPRED output by NONMEM\n  for each of the {n_chains} chains.\"\n)\netas_text <- glue(\n  \"ETAs are medians of the values\n  of ETA output by NONMEM for each of the {n_chains} chains.\"\n)\nif (params$sims_output_path == \"\") {\n  # Medians of NONMEM output only\n  pop_pred_text <- glue(\n    \"Population predictions are medians of the values of EPRED output by NONMEM\n    for each of the {n_chains} chains.\"\n  )\n  dv_pred_text <- glue(pop_pred_text, ind_pred_text, .sep = \" \")\n  npde_text <- glue(\n    \"Normalized prediction distribution errors (NPDE) are medians of the values\n    of NPDE output by NONMEM for each of the {n_chains} chains.\"\n  )\n  ewres_text <- glue(\n    \"Expected weighted residuals (EWRES) are medians of the values\n    of EWRES output by NONMEM for each of the {n_chains} chains.\"\n  )\n} else {\n  # Medians (and optionally upper/lower percentiles) from simulations\n  pop_pred_text <- glue(\n    \"Population predictions are medians of {params$n_post} simulated values\n    incorporating between-{ifelse(params$resid_var, ' and within-', '')}subject\n    variability, as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n  if (params$ipred_sim) {\n    ind_pred_text <- glue(\n      \"Individual predictions are medians of {params$n_post} simulated values\n      incorporating conditional estimates of individual parameters and include\n      {ifelse(params$resid_var, 'within-subject variability, as well as', '')}\n      uncertainty in population parameter estimates via sampling from the\n      posterior distribution.\"\n    )\n    etas_text <- glue(\n      \"ETAs are medians of {params$n_post} posterior ETAs across\n      the {n_chains} chains.\"\n    )\n  }\n  dv_pred_text <- glue(pop_pred_text, ind_pred_text, .sep = \" \")\n  if (params$plot_ci) {\n    dv_pred_text <- glue(\n      dv_pred_text,\n      \" Red error bars represent {params$ci_level}% CIs.\"\n    )\n  }\n  npde_text <- glue(\n    \"Normalized prediction distribution errors (NPDE) are Monte-Carlo generated\n    diagnostics, using {params$n_post} simulations incorporating\n    between-{ifelse(params$resid_var, ' and within-', '')}subject variability,\n    as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n  ewres_text <- glue(\n    \"Expected weighted residuals (EWRES) are Monte-Carlo generated residuals,\n    using {params$n_post} simulations incorporating\n    between-{ifelse(params$resid_var, ' and within-', '')}subject variability,\n    as well as uncertainty in population parameter estimates via\n    sampling from the posterior distribution.\"\n  )\n}\n```\n\n\n\n# General diagnostic plots\n\nThe following plots assume that the preferred x-axis labels are defined here. \n\n```{r xAxis_label_names, echo = params$include_code}\n### Ideally get units from yaml\n\nxTIME <- \"TIME //Time (h)\"\nxTAD <- \"TAD //Time after dose (h)\"\nxPRED <- \"EPRED //Population predicted concentration\"\nyEWRES <- \"EWRES //Expected weighted residual\"\nyNPDE <- \"NPDE //Normalized prediction distribution error\"\n```\n\n## DV vs population and individual predictions\n\nCreate plots of DV vs population and individual predictions for the full dataset\nand stratified by renal function and hepatic function.\n\n```{r DV_PRED_plots, echo = params$include_code, message=FALSE}\n# DV vs population predictions\ndv_pred_ci <- function(data, scales_free = FALSE) {\n  p <- ggplot(data = data, aes(x = EPRED, y = DV)) + \n    geom_errorbarh(aes(xmin = EPRED_lo, xmax = EPRED_hi), \n                   colour = \"red3\", alpha = 0.3) + \n    geom_point() + \n    xlab(glue(\"Population predicted value\")) + ylab(\"Observed value\") +  \n    pm_abline() + pm_smooth() + pm_theme()\n  if (!scales_free) {\n    p <- p +\n      lims(\n        x = c(0, max(data$EPRED_hi)),\n        y = c(0, max(data$EPRED_hi))\n      )\n  }\n  p\n}\nif (params$plot_ci & params$sims_output_path != \"\") {\n  dvp <- dv_pred_ci(data)\n  # by renal function\n  dvp_rf <- dv_pred_ci(data, scales_free = TRUE) +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvp_cp <- dv_pred_ci(data, scales_free = TRUE) +\n    facet_wrap(~CP, scales = \"free\")\n} else {\n  dvp <- dv_pred(data, x = \"EPRED//Population predicted {xname}\")\n  # by renal function\n  dvp_rf <- dv_pred(data, x = \"EPRED//Population predicted {xname}\", scales = \"free\") +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvp_cp <- dv_pred(data, x = \"EPRED//Population predicted {xname}\", scales = \"free\") +\n    facet_wrap(~CP, scales = \"free\")\n}\n\n# DV vs individual predictions\ndv_ipred_ci <- function(data, scales_free = FALSE) {\n  p <- ggplot(data = data, aes(x = IPRED, y = DV)) + \n    geom_errorbarh(aes(xmin = IPRED_lo, xmax = IPRED_hi), \n                   colour = \"red3\", alpha = 0.3) + \n    geom_point() + \n    xlab(\"Individual predicted value\") + ylab(\"Observed value\") +  \n    pm_abline() + pm_smooth() + pm_theme()\n  if (!scales_free) {\n    p <- p +\n      lims(\n        x = c(0, max(data$IPRED_hi)),\n        y = c(0, max(data$IPRED_hi))\n      )\n  }\n  p\n}\nif (params$plot_ci & params$sims_output_path != \"\" &\n    \"IPRED_lo\" %in% names(data)) {\n  dvip <- dv_ipred_ci(data)\n  # by renal function\n  dvip_rf <- dv_ipred_ci(data, scales_free = TRUE) +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvip_cp <- dv_ipred_ci(data, scales_free = TRUE) +\n    facet_wrap(~CP, scales = \"free\")\n} else {\n  dvip <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\")\n  # by renal function\n  dvip_rf <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\", scales = \"free\") +\n    facet_wrap(~RF, scales = \"free\")\n  # by hepatic function\n  dvip_cp <- dv_ipred(data, x = \"IPRED//Individual predicted {xname}\", scales = \"free\") +\n    facet_wrap(~CP, scales = \"free\")\n}\n\np <- pm_grid(list(dvp, dvip), nrow = 2, ncol = 1)\n```\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\ndv_pred_text\n```\n\n```{r include_DV_PRED, include=params$include_plots, echo=F, message=FALSE}\np\n```\n\nDV vs population and individual predictions by renal function\n\n```{r include_DV_PRED_rf, include=params$include_plots, echo=F, message=FALSE}\ndvp_rf ; dvip_rf\n```\n\nDV vs population and individual predictions by hepatic function\n\n```{r include_DV_PRED_cp, include=params$include_plots, echo=F, message=FALSE}\ndvp_cp ; dvip_cp\n```\n\n\n```{r save_DV_PRED, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"dv-pred-ipred\"),\n  width = 5,\n  height = 7\n)\n\n\nmrggsave(\n  list(dvp_rf, dvip_rf), \n  stem = c(params$run, \"dv-pred-ipred-byRF\"),\n  width = 5,\n  height = 5\n)\nmrggsave(\n  list(dvp_cp, dvip_cp), \n  stem = c(params$run, \"dv-pred-ipred-byCP\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm_dv_pred, include=F}\nrm(p, dvp, dvip, dvp_rf, dvip_rf, dvp_cp, dvip_cp)\n```\n\n\n## NPDE plots\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\nnpde_text\n```\n\nNPDE vs population predictions, time and time after dose.\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\npop_pred_text\n```\n\n```{r NPDE_plots, echo = params$include_code, message = FALSE}\n## Plan to display these three plots in a single, 3 panel figure and so the y-axis\n## labels are removed manually for display purposes\np1 <- npde_pred(data, x = xPRED, y = \"NPDE //  \")\np2 <- npde_time(data, x = xTIME)\np3 <- npde_tad(data, x = xTAD, y = \"NPDE //  \")\n\np <- pm_grid(list(p1, p2, p3), nrow = 3, ncol = 1)\n```\n\n```{r include_NPDE, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE, fig.height = 7}\np\n```\n\n```{r save_NPDE, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-pred-time-tad\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2, include = F}\nrm(p)\n```\n\n\nNPDE vs continuous covariates\n\n```{r NPDE_cont_cov_plots, echo = params$include_code, message = FALSE}\nNPDEco <- spec %>%\n  ys_select(params$contCov) %>% # select the covariates of interest\n  axis_col_labs(\n    title_case = TRUE, # converts yspec short to title_case\n    short_max = 20\n  ) # if yspec short is >10 characters it keeps the abbreviation\n\np1 <- npde_cont(data, x = NPDEco[1])\np2 <- npde_cont(data, x = NPDEco[2])\np3 <- npde_cont(data, x = NPDEco[3])\np4 <- npde_cont(data, x = NPDEco[4])\n\np <- pm_grid(list(p1, p2, p3, p4), ncol = 1)\n```\n\n```{r include_NPDE_cont_cov, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE, fig.height = 7}\np\n```\n\n```{r save_NPDE_cont_cov, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-cont-cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2_cont_cov, include = F}\nrm(p)\n```\n\nNPDE vs categorical covariates.\n\n```{r NPDE_cat_cov_plots, echo = params$include_code, message = FALSE}\nNPDEca <- spec %>%\n  ys_select(\"RF\", \"CP\") %>%   # select the covariates of interest\n  axis_col_labs(title_case = TRUE) # converts yspec short to title_case\n\np1 <- npde_cat(data, x = NPDEca[1])\np2 <- npde_cat(data, x = NPDEca[2]) + rot_x(45)\n\np <- pm_grid(list(p1, p2), nrow = 2, ncol = 1)\n```\n\n```{r include_NPDE_cat_cov, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_NPDE_cat_cov, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-cat-cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm2_cat_cov, include = F}\nrm(p)\n```\n\n\n## NPDE density histogram\n\n```{r npde_hist_plots, echo = params$include_code, message = FALSE}\np <- npde_hist(data)\n```\n\n```{r include_npde_hist, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_npde_hist, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"npde-hist\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm3, include = F}\nrm(p)\n```\n\n## EWRES vs population predictions, time and time after dose\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\newres_text\n```\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\npop_pred_text\n```\n\n```{r ewres_plots, echo = params$include_code, message=FALSE}\np_ewres_epred <- res_pred(data, x = xPRED, y = yEWRES)\np_ewres_time <- res_pred(data, x = xTIME, y = yEWRES)\np_ewres_tad <- res_pred(data, x = xTAD, y = yEWRES)\np <- pm_grid(\n  list(\n    p_ewres_epred,\n    p_ewres_time,\n    p_ewres_tad\n  ),\n  nrow = 3,\n  ncol = 1\n)\n```\n\n```{r include_ewres, eval=params$include_plots, include=params$include_plots, echo=F, message=FALSE, fig.height = 7}\np\n```\n\n```{r save_ewres, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"ewres-epred-time-tad\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm_ewres_plots, include=F}\nrm(p)\n```\n\n\n\n## EWRES qq and density plot\n\n```{r ewres_qq_density_plots, echo = params$include_code, message=FALSE}\np_ewres_q <- wres_q(data, \"EWRES\")\np_ewres_hist <- cont_hist(data, \"EWRES\", y = \"..density..\")\np <- pm_grid(list(p_ewres_q, p_ewres_hist), nrow = 2, ncol = 1)\n```\n\n```{r include_ewres_qq_density, eval=params$include_plots, include=params$include_plots, echo=F, message=FALSE}\np\n```\n\n```{r save_ewres_qq_density, include = FALSE, eval = params$run_mrggsave, message=FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"ewres-qq-hist\"),\n  width = 5,\n  height = 7\n)\n```\n\n```{r rm_ewres_qq_density, include=F}\nrm(p)\n```\n\n\n\n# EBEs-based diagnostics\n\n```{r results=\"asis\", include=params$include_plots, echo=F}\netas_text\n```\n\n\n\n## ETA pairs plot \n\n```{r eta_pairs_plots, echo = params$include_code, message = FALSE}\np <- eta_pairs(id, params$etas)\n```\n\n```{r include_eta_pairs, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_pairs, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta\", \"pairs\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm5, include = F}\nrm(p)\n```\n\n\n\n\n\n## Continuous covariate plots\n\nThese plots uses yspec to automatically rename the axis labels.\n\n```{r get_cont_cov_labels, echo = params$include_code}\nco <- spec %>%\n  ys_select(params$contCov) %>% # select the covariates of interest\n  axis_col_labs(\n    title_case = TRUE, # converts yspec short to title_case\n    short_max = 20\n  ) # if yspec short is >10 characters it keeps the abbreviation\n```\n\n### ETA vs continuous covariates\n\nNote that here we use a function that maps over the ETAs (not the covariates)\nbecause the purpose of these plots was to determine whether there were any\ntrends in the covariates for a given ETA. This may need to be edited to address\ndifferent study specific questions\n\n```{r eta_vs_cont_plots, echo = params$include_code, message = FALSE}\np <- purrr::map(.x = params$etas, ~ map_wrap_eta_cont(.x, co, id, .ncol = 1))\n```\n\n```{r include_eta_vs_cont, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_vs_cont, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta-all\", \"cont\", \"cov\"),\n  width = 5,\n  height = 5\n)\n```\n\n```{r rm6, include = F}\nrm(p)\n```\n\n### Continuous covariate pairs plot\n\n```{r contCov_pairs_plots, echo = params$include_code, message = FALSE}\nco2 <- str_replace(co, \"\\\\(\", \"\\n(\")\np <- eta_pairs(id, co2) + rot_x(45)\n```\n\n```{r include_contCov_pairs, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_contCov_pairs, include = FALSE, eval = params$run_mrggsave, message = FALSE}\nmrggsave(\n  p,\n  stem = c(params$run, \"eta\", \"all\", \"contCov\", \"pairs\"),\n  width = 5,\n  height = 6\n)\n```\n\n```{r rm7, include = F}\nrm(p)\n```\n\n\n## Categorical covariate plots\n\nThese plots uses the yspec to automatically rename the axis labels.\n\n```{r get_cat_cov_labels, echo = params$include_code}\nca <- spec %>%\n  ys_select(params$catCov) %>% # select the covariates of interest\n  axis_col_labs(title_case = TRUE) # converts yspec short to title_case\n```\n\n\n### ETA vs categorical covariates\n\nNote that here we use a function that maps over the covariates (not the ETAs)\nbecause the purpose of these plots was to determine whether there is any\ndifference in the distribution of ETAs across studies, dosing groups and disease\nstates. This should be updated to reflect the questions you're trying to\naddress.\n\n\n```{r eta_vs_cat_plots, echo = params$include_code, message = FALSE}\nif (length(params$etas) > 1) {\n  p <- purrr::map(.x = ca, ~ map_eta_cat(.x, params$etas, id))\n} else {\n  ## CHECK: depending on the labels, this may need to be changed\n  p <- purrr::map(.x = ca, ~ eta_cat(id, .x, params$etas) + rot_x(35))\n}\n\npList <- pm_grid(list(p[[1]], p[[2]]), nrow = 2, ncol = 1)\n```\n\n```{r include_eta_vs_cat, eval = params$include_plots, include = params$include_plots, echo = F, message = FALSE}\np\n```\n\n```{r save_eta_vs_cat, include = FALSE, eval = params$run_mrggsave, message = FALSE}\n## As of mrggsave v0.4.0, if you pass mrggsave a named list of plots, it will use this to\n## name the plots that it writes out (regardless of whether stem is defined).\n## If you don't want to use this feature, you can pass unname(p), instead of just p\nmrggsave(\n  list(pList, unname(p)),\n  stem = c(params$run, \"eta\", \"all\", \"cat\", \"cov\"),\n  width = 5,\n  height = 7\n)\n```\n\n\n# Session details\n\nIt is considered good practice to include these details at the end of all rmd scripts\n\n```{r details, include = TRUE}\nSys.getenv(\"AMI_NAME\")\nsessioninfo::session_info()\nbbr::bbi_version()\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"html_document":{"toc":true,"toc_float":true,"depth":2}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"model_diagnostic_bayes_trial.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","title":"Model diagnostics","params":{"run":"5","logDV":false,"include_code":false,"include_plots":true,"sims_output_path":"","n_post":1000,"resid_var":true,"ipred_sim":true,"ci_level":95,"plot_ci":false,"run_mrggsave":true}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}